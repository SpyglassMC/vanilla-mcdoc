use ::java::util::text::Text
use ::java::util::InclusiveRange

type ResourcePack = Pack<int @ 1..64, int @ 65..>
type DataPack = Pack<int @ 4..81, int @ 82..>

type Pack<TOldRange, TNewRange> = (
	BasePack<OldPackVersionInfo<TOldRange>, OldPackOverlays<TOldRange>>
	| BasePack<NewPackVersionInfo<TNewRange>, NewOrIntermediatePackOverlays<TNewRange>>
	| BasePack<IntermediatePackVersionInfo<TOldRange, TNewRange>, IntermediatePackOverlays<TOldRange>>
)

// `supported_formats` and `overlays` were introduced in 1.20.2,
// but multi-version packs will use these with an older pack_format.
type BasePack<VersionInfo, TOverlays> = struct {
	pack: VersionInfo,
	#[since="1.19"]
	filter?: PackFilter,
	#[since="1.19.3"]
	features?: PackFeatures,
	#[since="1.20.2"]
	overlays?: TOverlays,
}

type OldPackVersionInfo<TOldRange> = struct {
	pack_format: #[pack_format] TOldRange,
	// This is technically only allowed to be a list of two integers in 21w31a, but that's likely
	// a bug.
	#[since="1.20.2"]
	supported_formats?: InclusiveRange<#[pack_format] TOldRange>,
}

type NewPackVersionInfo<TNewRange> = struct {
	pack_format?: #[pack_format] PackFormat<TNewRange>,
	min_format: #[pack_format] PackFormat<TNewRange>,
	max_format: #[pack_format] PackFormat<TNewRange>,
}

type IntermediatePackVersionInfo<TOldRange, TNewRange> = struct {
	pack_format: #[pack_format] int,
	min_format: #[pack_format] PackFormat<TOldRange>,
	max_format: #[pack_format] PackFormat<TNewRange>,
	supported_formats: [#[pack_format] TOldRange, #[pack_format] TNewRange],
}

type PackVersionInfo<TOldRange, TNewRange> = (OldPackVersionInfo<TOldRange> | NewPackVersionInfo<TNewRange> | IntermediatePackVersionInfo<TOldRange, TNewRange>)

type PackFormat<T> = (T | [T] @ 1 | [T, int @ 0..])

struct PackFilter {
	block: [BlockPattern],
}

struct BlockPattern {
	namespace?: #[regex_pattern] string,
	path?: #[regex_pattern] string,
}

struct PackFeatures {
	enabled: [#[id] FeatureFlag],
}

enum(string) FeatureFlag {
	Vanilla = "vanilla",
	#[until="1.20"] Update120 = "update_1_20",
	#[until="1.21.2"] Bundle = "bundle",
	#[since="1.20.2"] TradeRebalance = "trade_rebalance",
	#[since="1.20.3"] #[until="1.21"] Update121 = "update_1_21",
	#[since="1.21.2"] RedstoneExperiments = "redstone_experiments",
	#[since="1.21.2"] MinecartImprovements = "minecart_improvements",
	#[since="1.21.2"] #[until="1.21.4"] WinterDrop = "winter_drop",
}

type OldPackOverlays<TOldRange> = PackOverlays<OldPackOverlay<TOldRange>>
type NewPackOverlays<TNewRange> = PackOverlays<NewPackOverlay<TNewRange>>

// This enforces all overlays to include the formats field. min_version and max_version also must
// be present if the format is outside the TOldRange, and are otherwise optional.
type IntermediatePackOverlays<TOldRange> = PackOverlays<
	(OldPackOverlay<TOldRange> | IntermediatePackOverlay)
>

// This enforces either a list of overlays without the formats field and only
// min_version and max_version, or a list that always has the formats field, and for versions
// outside of TOldRange, min_format and max_format become optional.
//
// This is used in case the min_format / max_format range is in the TNewRange. This still allows
// for overlays for versions outside of the range without guranteeing compatiblity.
//
// In Minecraft, it is only possible to define overlays with the `formats` field if at least one
// overlay is targeting TOldRange. This is not validated by this type due to limitations of mcdoc.
type NewOrIntermediatePackOverlays<TOldRange, TNewRange> = (
	IntermediatePackOverlays<TOldRange> |
	NewPackOverlays<TNewRange>
)

type PackOverlays<T> = struct {
	entries: [T],
}

type OldPackOverlay<TOldRange> = struct {
	directory: string @ 1..,
	// This is technically only allowed to be a list of two integers in 21w31a, but that's likely
	// a bug.
	formats: InclusiveRange<#[pack_format] TOldRange>,
}

type NewPackOverlay<TNewRange> = struct {
	directory: string @ 1..,
	min_format: #[pack_format] PackFormat<TNewRange>,
	max_format: #[pack_format] PackFormat<TNewRange>,
}

struct IntermediatePackOverlay {
	directory: string @ 1..,
	formats: [#[pack_format] int] @ 2,
	min_format: #[pack_format] PackFormat<int>,
	max_format: #[pack_format] PackFormat<int>,
}
