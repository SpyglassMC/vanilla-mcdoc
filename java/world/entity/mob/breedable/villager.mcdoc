use ::java::world::item::ItemStack
use ::java::world::item::ItemCost

struct VillagerBase {
	/// Slots from 0 to 7.
	Inventory?: [ItemStack] @ 0..8,
	/// Trade offers it has.
	Offers?: Offers,
}

dispatch minecraft:entity[villager] to struct Villager {
	...super::Breedable,
	...VillagerBase,
	VillagerData?: VillagerData,
	/// Determines whether the villager will be available to reproduce.
	///
	/// When the value is `12` the villager can reproduce.
	///
	/// After reproducing, the value is reset to `0`.
	///
	/// To increase this value villagers will pick up food that is in range.
	///
	/// Foods: Potatoes, Carrots, & Beetroots increase the level by `1`. Bread increases the level by `4`.
	FoodLevel?: byte @ 0..12,
	// TODO: determine how often villagers get an `interaction_target` memory and find exact sharing math.
	/// Affects per-player reputation which affects trade offer pricing and iron golem behavior.
	///
	/// Reputation is assembled through events the villager has witnessed (within 16 blocks) or heard about from other villagers through gossip.
	///
	/// All reputation parts decay over time except `major_positive` which is only ever increased (when the villager is cured).
	///
	/// Decay occurs every 24k ticks (20 minutes), tracked by `LastGossipDecay`.
	///
	/// Once a reputation part decays to zero it is removed from the list.
	Gossips?: [PlayerReputationPart],
	/// Last game-tick every gossip significance `Value` could have decayed.
	///
	/// Once this reaches 24k (20 minutes) less than the current game tick a decay occurs again.
	LastGossipDecay?: long,
	/// Last game-tick it removed `uses` & updated `demand` of every trade offer by going to its `job_site`.
	LastRestock?: long,
	/// Times it has reset the `uses` & updated `demand` of every trade offer by going to its `job_site` in the past 12k ticks (10 minutes).
	///
	/// Time is tracked by `LastRestock`.
	///
	/// When two restocks have occurred, another restock (and reset of this value to `0`) will only occur after 10 minutes.
	RestocksToday?: int @ 0..2,
	/// XP it has, increases when trades are used by each trade offer's `xp` value.
	///
	/// After `250` the XP will continue to increase, but will do nothing more.
	///
	/// Trade tiers:
	/// - `0..9`     - Tier 1: Novice
	/// - `10..69`   - Tier 2: Apprentice
	/// - `70..149`  - Tier 3: Journeyman
	/// - `150..249` - Tier 4: Expert
	/// - `250..`    - Tier 5: Master
	Xp?: int @ 0..,
}

struct VillagerData {
	/// Used for trading and badge rendering.
	level?: int,
	profession?: #[id="villager_profession"] string,
	type?: #[id="villager_type"] string,
}

struct PlayerReputationPart {
	Type?: ReputationPart,
	Value?: minecraft:reputation_part_value[[Type]],
	// This version is a guess
	#[until="1.16"]
	...struct {
		/// Upper bits of the UUID of the player that caused the gossip-worthy event(s) related to this reputation part.
		TargetMost?: long,
		/// Lower bits of the UUID of the player that caused the gossip-worthy event(s) related to this reputation part.
		TargetLeast?: long,
	},
	/// UUID of the player that caused the gossip-worthy event(s) related to this reputation part.
	#[since="1.16"]
	Target?: #[uuid] int[] @ 4,
}

enum(string) ReputationPart {
	/// Caused by the villager being directly killed, increasing by 25 each time.
	///
	/// Increases others' `major_negative` by 15 when shared through gossip.
	///
	/// Decays by 10 every 20 minutes.
	MajorNegative = "major_negative",
	/// Caused by the villager being directly hurt, increasing by 25 each time
	///
	/// Increases others' `major_negative` by 5 when shared through gossip.
	///
	/// Decays by 20 every 20 minutes.
	MinorNegative = "minor_negative",
	/// Caused by the villager being cured, is always set to 20.
	///
	/// Does not increase others' `major_positive` through gossip.
	///
	/// Does not decay.
	MajorPositive = "major_positive",
	/// Caused by the villager being cured, is increased by 25 each time.
	///
	/// Increases others' `minor_positive` by 20 when shared through gossip.
	///
	/// Decays by 1 every 20 minutes.
	MinorPositive = "minor_positive",
	/// Caused by trading with the villager, increasing by 2 each time.
	///
	/// Does not increase others' `trading` through gossip.
	///
	/// Decays by 2 every 20 minutes.
	Trading = "trading",
}

dispatch minecraft:reputation_part_value[major_negative] to (int @ 5..100)

dispatch minecraft:reputation_part_value[minor_negative] to (int @ 5..200)

dispatch minecraft:reputation_part_value[major_positive] to 20

dispatch minecraft:reputation_part_value[minor_positive] to (int @ 1..25)

dispatch minecraft:reputation_part_value[trading] to (int @ 1..25)

struct Offers {
	/// Trades it has to offer.
	Recipes?: [Recipe],
}

struct Recipe {
	/// Whether it should reward experience for using this trade. 
	///
	/// Experience amount is `3 + random(0, 3)` plus `5` if the trade is causing the merchant to increase in tier.
	rewardExp?: boolean,
	/// Maximum number of uses for this trade before the merchant has to restock.
	maxUses?: int @ 0..,
	/// Times this trade has been used since the merchant last restocked.
	uses?: int @ 0..,
	// TODO: Provide a link to a gist with the full explanation. 
	/// Price item required by the merchant, count is modified depending on `demand` & per-player context.
	buy?: ItemCost,
	/// Second item required by the merchant, count does not change.
	buyB?: ItemCost,
	/// Item being offered by the merchant.
	sell?: ItemStack,
	/// XP the merchant gains from the trade.
	xp?: int @ 0..,
	/// How much demand & reputation each affect the count of the `buy` item.
	priceMultiplier?: float,
	// TODO: What stage in the calculation is this added to
	/// Modifier added to the original count of the `buy` item.
	specialPrice?: int,
	// TODO: Phrasing (requires actually understanding it first lol)
	/// Count adjuster of the `buy` item based on demand.
	///
	/// Minus twice the number of times the villager has the trade in stock.
	/// When restocking subtract the number of possible purchases before running out of stock and add twice the number of actually made purchases.
	/// When the demand becomes positive, the count is increased by the initial count times `priceMultiplier` times the demand. 
	demand?: int,
}

dispatch minecraft:entity[wandering_trader] to struct WanderingTrader {
	...super::super::MobBase,
	...VillagerBase,
	/// Ticks until it despawns.
	DespawnDelay?: int,
	/// Where it is heading to.
	#[until="1.20.5"]
	WanderTarget?: WanderTarget,
	/// Where it is heading to.
	#[since="1.20.5"]
	wander_target?: int[] @ 3,
}

struct WanderTarget {
	X?: int,
	Y?: int,
	Z?: int,
}
