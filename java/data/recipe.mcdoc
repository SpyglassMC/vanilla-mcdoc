dispatch minecraft:resource[recipe] to struct Recipe {
	type: #[id=recipe_serializer] string,
	...minecraft:recipe_serializer[[type]],
}

dispatch minecraft:recipe_serializer[crafting_shaped] to struct CraftingShaped {
	group?: string, // TODO
	category?: CraftingBookCategory,
	pattern: [string @ 1..3] @ 1..3, // TODO
	key: struct {
		[string]: Ingredient,
	},
	result: ItemResult,
	#[since="1.19.4"]
	/// Determines if a notification is shown when unlocking this recipe. Defaults to true.
	show_notification?: boolean
}

dispatch minecraft:recipe_serializer[crafting_shapeless] to struct CraftingShapeless {
	group?: string,
	category?: CraftingBookCategory,
	ingredients?: [Ingredient] @ 1..9,
	result: ItemResult,
}

dispatch minecraft:recipe_serializer[smelting,blasting,smoking,campfire_cooking] to struct Smelting {
	group?: string,
	category?: CookingBookCategory,
	ingredient: Ingredient,
	result: #[id=item] string,
	experience?: float,
	cookingtime?: int,
}

dispatch minecraft:recipe_serializer[stonecutting] to struct Stonecutting {
	group?: string,
	ingredient: Ingredient,
	result: #[id=item] string,
	count: int,
}

#[until=1.20]
dispatch minecraft:recipe_serializer[smithing] to struct Smithing {
	base: IngredientValue,
	addition: IngredientValue,
	result: ItemResult,
}

#[since="1.19.4"]
dispatch minecraft:recipe_serializer[smithing_trim] to struct SmithingTrim {
	/// Ingredient specifying an item to be trimmed. (eg. `{ "tag": "minecraft:trimmable_armor" }`)
	base: Ingredient,
	/// Material that will be used. (eg. `{ "tag": "minecraft:trim_materials" }`)
	addition: Ingredient,
	/// Template item that will be used for the pattern.
	template: Ingredient,
}

#[since="1.19.4"]
dispatch minecraft:recipe_serializer[smithing_transform] to struct SmithingTransform {
	/// Ingredient specifying an item to be transformed. (eg. `{ "tag": "minecraft:diamond_helmet" }`)
	base: Ingredient,
	/// Material that will be used for transforming. (eg. `{ "tag": "minecraft:netherite_ingot" }`)
	addition: Ingredient,
	/// Template item that will be used for the item transformation.
	template: Ingredient,
	/// Resulting transformed item
	result: struct {
		item: #[id=item] string, // Fun
	},
}

struct ItemResult {
	item: #[id=item] string,
	count?: int
}

type Ingredient = (
	IngredientValue |
	[IngredientValue] |
)

type IngredientValue = (
	struct {
		item: #[id=item] string,
	} |
	struct {
		tag: #[id(registry=item,tags=implicit)] string,
	} |
)

enum(string) CraftingBookCategory {
	Building = "building",
	Redstone = "redstone",
	Equipment = "equipment",
	Misc = "misc",
}

enum(string) CookingBookCategory {
	Food = "food",
	Blocks = "blocks",
	Misc = "misc",
}
