dispatch minecraft:data_component[map_color] to #[color=composite_int] int

dispatch minecraft:data_component[map_decorations] to struct MapDecorations {
	[string]: Decoration
}

dispatch minecraft:data_component[map_id] to int

dispatch minecraft:item[filled_map] to struct FilledMap {
	/// Calculated as `RED << 16 | GREEN << 8 | BLUE`. Each of these fields must be between 0 and 255, inclusive.
	#[since="1.20.5"]
	[#[id] "map_color"]?: minecraft:data_component[map_color],
	/// Key-value pairs of the icons to display, where the key is an arbitrary unique string identifying the decoration.
	#[since="1.20.5"]
	[#[id] "map_decorations"]?: minecraft:data_component[map_decorations],
	/// Map number, representing the shared state holding map contents and markers.
	#[since="1.20.5"]
	[#[id] "map_id"]?: minecraft:data_component[map_id],

	/// Map number, representing the shared state holding map contents and markers.
	#[until="1.20.5"]
	map: int,
	/// Amount to increase the current map scale by when crafting.
	#[until="1.20.5"]
	map_scale_direction: int @ 1..,
	/// Whether the map should be locked after being taken out of the cartography table.
	#[until="1.20.5"]
	map_to_lock: boolean,
	/// Decorations on the map.
	#[until="1.20.5"]
	Decorations: [struct {
		...Decoration,
		/// An arbitrary unique string identifying the decoration.
		id: string,
	}],
	/// Display for the item.
	#[until="1.20.5"]
	display: struct {
		...super::Display,
		/// Calculated as `RED << 16 | GREEN << 8 | BLUE`. Each of these fields must be between 0 and 255, inclusive.
		MapColor: #[color=composite_int] int,
	},
}

struct Decoration {
	/// Decoration type.
	type: (
		#[since="1.20.5"] IconStringId |
		#[until="1.20.5"] IconByteId |
	),
	/// World x position.
	x: double,
	/// World z position.
	z: double,
	/// Rotation of the decoration, measured in degrees clockwise.
	rot: float,
}

enum(string) IconStringId {
	/// White pentagon.
	Player = "player",
	/// Green pentagon.
	Frame = "frame",
	/// Red pentagon.
	RedMarker = "red_marker",
	/// Blue pentagon.
	BlueMarker = "blue_marker",
	/// White x.
	TargetX = "target_x",
	/// Red triangle.
	TargetPoint = "target_point",
	/// Large white dot.
	PlayerOffMap = "player_off_map",
	/// Small white dot.
	PlayerOffLimits = "player_off_limits",
	/// Woodland mansion.
	Mansion = "mansion",
	/// Ocean monument.
	Monument = "monument",
	WhiteBanner = "white_banner",
	OrangeBanner = "orange_banner",
	MagentaBanner = "magenta_banner",
	LightBlueBanner = "light_blue_banner",
	YellowBanner = "yellow_banner",
	LimeBanner = "lime_banner",
	PinkBanner = "pink_banner",
	GrayBanner = "gray_banner",
	LightGrayBanner = "light_gray_banner",
	CyanBanner = "cyan_banner",
	PurpleBanner = "purple_banner",
	BlueBanner = "blue_banner",
	BrownBanner = "brown_banner",
	GreenBanner = "green_banner",
	RedBanner = "red_banner",
	BlackBanner = "black_banner",
	RedX = "red_x",
}

enum(byte) IconByteId {
	/// White pentagon.
	Player = 0,
	/// Green pentagon.
	Frame = 1,
	/// Red pentagon.
	RedMarker = 2,
	/// Blue pentagon.
	BlueMarker = 3,
	/// White x.
	TargetX = 4,
	/// Red triangle.
	TargetPoint = 5,
	/// Large white dot.
	PlayerOffMap = 6,
	/// Small white dot.
	PlayerOffLimits = 7,
	/// Woodland mansion.
	Mansion = 8,
	/// Ocean monument.
	Monument = 9,
	WhiteBanner = 10,
	OrangeBanner = 11,
	MagentaBanner = 12,
	LightBlueBanner = 13,
	YellowBanner = 14,
	LimeBanner = 15,
	PinkBanner = 16,
	GrayBanner = 17,
	LightGrayBanner = 18,
	CyanBanner = 19,
	PurpleBanner = 20,
	BlueBanner = 21,
	BrownBanner = 22,
	GreenBanner = 23,
	RedBanner = 24,
	BlackBanner = 25,
	RedX = 26,
}
